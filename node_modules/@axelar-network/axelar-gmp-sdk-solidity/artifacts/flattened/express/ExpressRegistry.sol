// Sources flattened with hardhat v2.13.0 https://hardhat.org

// File contracts/interfaces/IAxelarGateway.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IAxelarGateway {
    /**********\
    |* Errors *|
    \**********/

    error NotSelf();
    error NotProxy();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAuthModule();
    error InvalidTokenDeployer();
    error InvalidAmount();
    error InvalidChainId();
    error InvalidCommands();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error InvalidSetMintLimitsParams();
    error ExceedMintLimit(string symbol);

    /**********\
    |* Events *|
    \**********/

    event TokenSent(
        address indexed sender,
        string destinationChain,
        string destinationAddress,
        string symbol,
        uint256 amount
    );

    event ContractCall(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload
    );

    event ContractCallWithToken(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload,
        string symbol,
        uint256 amount
    );

    event Executed(bytes32 indexed commandId);

    event TokenDeployed(string symbol, address tokenAddresses);

    event ContractCallApproved(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event ContractCallApprovedWithMint(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        string symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event TokenMintLimitUpdated(string symbol, uint256 limit);

    event OperatorshipTransferred(bytes newOperatorsData);

    event Upgraded(address indexed implementation);

    /********************\
    |* Public Functions *|
    \********************/

    function sendToken(
        string calldata destinationChain,
        string calldata destinationAddress,
        string calldata symbol,
        uint256 amount
    ) external;

    function callContract(
        string calldata destinationChain,
        string calldata contractAddress,
        bytes calldata payload
    ) external;

    function callContractWithToken(
        string calldata destinationChain,
        string calldata contractAddress,
        bytes calldata payload,
        string calldata symbol,
        uint256 amount
    ) external;

    function isContractCallApproved(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view returns (bool);

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string calldata symbol,
        uint256 amount
    ) external view returns (bool);

    function validateContractCall(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash
    ) external returns (bool);

    function validateContractCallAndMint(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash,
        string calldata symbol,
        uint256 amount
    ) external returns (bool);

    /***********\
    |* Getters *|
    \***********/

    function authModule() external view returns (address);

    function tokenDeployer() external view returns (address);

    function tokenMintLimit(string memory symbol) external view returns (uint256);

    function tokenMintAmount(string memory symbol) external view returns (uint256);

    function allTokensFrozen() external view returns (bool);

    function implementation() external view returns (address);

    function tokenAddresses(string memory symbol) external view returns (address);

    function tokenFrozen(string memory symbol) external view returns (bool);

    function isCommandExecuted(bytes32 commandId) external view returns (bool);

    function adminEpoch() external view returns (uint256);

    function adminThreshold(uint256 epoch) external view returns (uint256);

    function admins(uint256 epoch) external view returns (address[] memory);

    /*******************\
    |* Admin Functions *|
    \*******************/

    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external;

    /**********************\
    |* External Functions *|
    \**********************/

    function setup(bytes calldata params) external;

    function execute(bytes calldata input) external;
}


// File contracts/interfaces/IAxelarExecutable.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IAxelarExecutable {
    error InvalidAddress();
    error NotApprovedByGateway();

    function gateway() external view returns (IAxelarGateway);

    function execute(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload
    ) external;

    function executeWithToken(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload,
        string calldata tokenSymbol,
        uint256 amount
    ) external;
}


// File contracts/interfaces/IExpressRegistry.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IExpressRegistry {
    error InvalidGateway();
    error NotExpressProxy();
    error AlreadyExpressCalled();

    function gateway() external returns (IAxelarGateway);

    function proxyCodeHash() external returns (bytes32);

    function registerExpressCallWithToken(
        address caller,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash,
        string calldata tokenSymbol,
        uint256 amount
    ) external;

    function processExecuteWithToken(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload,
        string calldata tokenSymbol,
        uint256 amount
    ) external;
}


// File contracts/interfaces/IExpressProxy.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;


interface IExpressProxy is IAxelarExecutable {
    error NotExpressRegistry();
    error InvalidTokenSymbol();
    error ExpressCallNotAccepted();

    function registry() external view returns (IExpressRegistry);

    function deployRegistry(bytes calldata registryCreationCode) external;

    function expressExecuteWithToken(
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload,
        string calldata tokenSymbol,
        uint256 amount
    ) external;

    function completeExecuteWithToken(
        address expressCaller,
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload,
        string calldata tokenSymbol,
        uint256 amount
    ) external;
}


// File contracts/express/ExpressRegistry.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;



contract ExpressRegistry is IExpressRegistry {
    IAxelarGateway public immutable gateway;
    bytes32 public immutable proxyCodeHash;

    mapping(bytes32 => address) private expressCallsWithToken;

    constructor(address gateway_, address proxy_) {
        if (gateway_ == address(0)) revert InvalidGateway();

        gateway = IAxelarGateway(gateway_);
        proxyCodeHash = proxy_.codehash;
    }

    function registerExpressCallWithToken(
        address expressCaller,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes32 payloadHash,
        string calldata tokenSymbol,
        uint256 amount
    ) external {
        _onlyProxy();

        (bytes32 slot, address existingExpressCaller) = _getExpressCallWithToken(
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            tokenSymbol,
            amount
        );

        if (existingExpressCaller != address(0)) revert AlreadyExpressCalled();

        _setExpressCallWithToken(slot, expressCaller);
    }

    function processExecuteWithToken(
        bytes32 commandId,
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload,
        string calldata tokenSymbol,
        uint256 amount
    ) external {
        _onlyProxy();

        bytes32 payloadHash = keccak256(payload);
        (bytes32 slot, address expressCaller) = _getExpressCallWithToken(
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            tokenSymbol,
            amount
        );

        if (
            gateway.isContractCallAndMintApproved(
                commandId,
                sourceChain,
                sourceAddress,
                msg.sender,
                payloadHash,
                tokenSymbol,
                amount
            ) && expressCaller != address(0)
        ) _setExpressCallWithToken(slot, address(0));

        IExpressProxy(msg.sender).completeExecuteWithToken(
            expressCaller,
            commandId,
            sourceChain,
            sourceAddress,
            payload,
            tokenSymbol,
            amount
        );
    }

    /// @notice internal function instead of a modifier to avoid stack too deep error
    function _onlyProxy() internal view {
        address proxyRegistry = address(IExpressProxy(msg.sender).registry());

        if (msg.sender.codehash != proxyCodeHash || proxyRegistry != address(this)) revert NotExpressProxy();
    }

    function _getExpressCallWithToken(
        string calldata sourceChain,
        string calldata sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string calldata symbol,
        uint256 amount
    ) internal view returns (bytes32 slot, address expressCaller) {
        slot = keccak256(abi.encode(sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount));
        expressCaller = expressCallsWithToken[slot];
    }

    function _setExpressCallWithToken(bytes32 slot, address expressCaller) internal {
        expressCallsWithToken[slot] = expressCaller;
    }
}
