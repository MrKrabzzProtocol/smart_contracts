{
  "language": "Solidity",
  "sources": {
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\n\ncontract AxelarExecutable is IAxelarExecutable {\n    IAxelarGateway public immutable gateway;\n\n    constructor(address gateway_) {\n        if (gateway_ == address(0)) revert InvalidAddress();\n\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\n            revert NotApprovedByGateway();\n\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (\n            !gateway.validateContractCallAndMint(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                tokenSymbol,\n                amount\n            )\n        ) revert NotApprovedByGateway();\n\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n    }\n\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\ninterface IAxelarExecutable {\n    error InvalidAddress();\n    error NotApprovedByGateway();\n\n    function gateway() external view returns (IAxelarGateway);\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// This should be owned by the microservice that is paying for gas.\ninterface IAxelarGasService {\n    error NothingReceived();\n    error InvalidAddress();\n    error NotCollector();\n    error InvalidAmounts();\n\n    event GasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\n\n    event ExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    // This is called on the source chain before calling the gateway to execute a remote contract.\n    function payNativeGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    function addGas(\n        bytes32 txHash,\n        uint256 txIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    function addExpressGas(\n        bytes32 txHash,\n        uint256 txIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    function addNativeExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    function collectFees(\n        address payable receiver,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external;\n\n    function refund(\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external;\n\n    function gasCollector() external returns (address);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAxelarGateway {\n    /**********\\\n    |* Errors *|\n    \\**********/\n\n    error NotSelf();\n    error NotProxy();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAuthModule();\n    error InvalidTokenDeployer();\n    error InvalidAmount();\n    error InvalidChainId();\n    error InvalidCommands();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error InvalidSetMintLimitsParams();\n    error ExceedMintLimit(string symbol);\n\n    /**********\\\n    |* Events *|\n    \\**********/\n\n    event TokenSent(\n        address indexed sender,\n        string destinationChain,\n        string destinationAddress,\n        string symbol,\n        uint256 amount\n    );\n\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload\n    );\n\n    event ContractCallWithToken(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload,\n        string symbol,\n        uint256 amount\n    );\n\n    event Executed(bytes32 indexed commandId);\n\n    event TokenDeployed(string symbol, address tokenAddresses);\n\n    event ContractCallApproved(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallApprovedWithMint(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\n\n    event OperatorshipTransferred(bytes newOperatorsData);\n\n    event Upgraded(address indexed implementation);\n\n    /********************\\\n    |* Public Functions *|\n    \\********************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload\n    ) external;\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view returns (bool);\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view returns (bool);\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external returns (bool);\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function authModule() external view returns (address);\n\n    function tokenDeployer() external view returns (address);\n\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\n\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\n\n    function allTokensFrozen() external view returns (bool);\n\n    function implementation() external view returns (address);\n\n    function tokenAddresses(string memory symbol) external view returns (address);\n\n    function tokenFrozen(string memory symbol) external view returns (bool);\n\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\n\n    function adminEpoch() external view returns (uint256);\n\n    function adminThreshold(uint256 epoch) external view returns (uint256);\n\n    function admins(uint256 epoch) external view returns (address[] memory);\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external;\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function setup(bytes calldata params) external;\n\n    function execute(bytes calldata input) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/KrabzToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// OPENZEPPLIN\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract KrabzToken is ERC20 {\n    constructor() ERC20(\"Krabz\", \"KRB\") {}\n\n    function mintKrabz(address _to, uint256 _amonut) public {\n        _mint(_to, _amonut);\n    }\n}\n"
    },
    "contracts/MrKrabz.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// OPENZEPPLIN\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// AXELAR\nimport {AxelarExecutable} from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\";\nimport {IAxelarGateway} from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\";\nimport {IAxelarGasService} from \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\";\n\n// TELLOR\nimport \"usingtellor/contracts/UsingTellor.sol\";\n\ncontract MrKrabz is UsingTellor, AxelarExecutable {\n    ////// CONTRACTS ////\n    // axelar gas service\n    IAxelarGasService public immutable gasService;\n\n    ///// STRUCT's //////\n\n    // round multi chain balance\n    struct CrossChainBalance {\n        uint256 fil;\n        uint256 matic;\n        uint256 krabz;\n    }\n\n    // ticket struct\n    struct Ticket {\n        address owner;\n        uint256 ID;\n        uint256[3] selectedNumbers;\n        bool withdrawn;\n        uint256 originChain;\n    }\n\n    // round struct\n    struct Round {\n        string roundName;\n        uint256 roundId;\n        uint256 ticketsPurchased;\n        uint256 roundEndTime;\n        uint256 ticketPrice;\n        uint256[3] roundWinningNumbers;\n        bool roundState; // true = winners decided ? false = anyone can participate\n        CrossChainBalance balance;\n    }\n\n    // user struct\n    struct User {\n        address user;\n        uint256 totalTicketsPurchased;\n        uint256 totalWinnings;\n        CrossChainBalance balance;\n    }\n\n    ////// ADDRESSES /////\n    address public aUsdcTokenAddress;\n\n    address public krabzTokenAddress;\n\n    address public deployer;\n\n    ///// UINT256's //////\n\n    // chain ids (TESTNET)\n    uint256 public FILECOIN_CHAIN_ID = 3141;\n    uint256 public POLYGON_CHAIN_ID = 80001;\n\n    // execution path handlers\n    uint256 public topUpWalletPath = 1;\n    uint256 public buyTicketPath = 2;\n    uint256 public newRoundPath = 3;\n    uint256 public setRandomWinnersPath = 4;\n    uint256 public claimWinningsPath = 5;\n\n    // current round id\n    uint256 public currentRound;\n\n    // max ticket per round\n    uint256 public MAX_TICKET_PER_ROUND = 3;\n\n    // predicatble val\n    uint256 public PREDICTABLE_VALUE = 12983786;\n\n    //// STRINGS ////\n\n    // chain names\n    string public filecoinChain = \"filecoin\";\n    string public polygonChain = \"Polygon\";\n\n    // destination address\n    string public filecoinDestinationAddr;\n    string public polygonDestinationAddr;\n\n    // gas token symbol\n    string public ausdcTokenSymbol = \"aUSDC\";\n\n    ///// MAPPING's /////\n\n    // user address to user struct\n    mapping(address => User) public userDetails_;\n\n    // round to ticket id to ticket\n    mapping(uint256 => mapping(uint256 => Ticket)) public roundToticketId_;\n\n    // round id to round struct\n    mapping(uint256 => Round) public roundIdToRoundDetails_;\n\n    // tickets purcahsed per round\n    mapping(uint256 => mapping(address => uint256)) public ticketsPurchasedPerRound_;\n\n    // round to tickets purchased\n    mapping(uint256 => Ticket[]) public roundIdToTicketList_;\n\n    //  CONSTRUCTOR\n    constructor(\n        address _gateway,\n        address _gasReceiver,\n        address payable _tellorAddress,\n        address _aUsdcTokenAddress,\n        address _krabzTokenAddress\n    ) UsingTellor(_tellorAddress) AxelarExecutable(_gateway) {\n        // gas service\n        gasService = IAxelarGasService(_gasReceiver);\n\n        // usdc token address\n        aUsdcTokenAddress = _aUsdcTokenAddress;\n\n        // krabz token address\n        krabzTokenAddress = _krabzTokenAddress;\n\n        //_aUsdcTokenAddress\n\n        // deployer\n        deployer = msg.sender;\n    }\n\n    ///// MAIN CONTRACT FUNCTIONS //////\n\n    // top up wallet balance\n    function topUpWalletBalance(\n        uint256 _amount,\n        bool _nativeAsset,\n        uint256 _estimateGasAmountOne\n    ) public payable {\n        // decide amount\n        uint256 amount;\n        if (_nativeAsset) amount = msg.value;\n        else {\n            amount = _amount;\n            // transfer krabz token\n            IERC20(krabzTokenAddress).transferFrom(msg.sender, address(this), _amount);\n        }\n\n        // make the cross chain call\n        _handleTopUpWalletBalanceCrossChain(\n            amount,\n            _nativeAsset,\n            msg.sender,\n            _estimateGasAmountOne\n        );\n    }\n\n    // buy ticket\n    function buyTicket(\n        uint256[3] memory _selectedNumbers,\n        bool _nativeAsset,\n        uint256 _estimateGasAmountOne\n    ) public {\n        // has the end time for the round passed ?\n        uint256 roundEndTime = roundIdToRoundDetails_[currentRound].roundEndTime;\n        if (block.timestamp > roundEndTime) revert(\"Round Passed!\");\n\n        // round entry state passed: currently in deciding winners state\n        if (roundIdToRoundDetails_[currentRound].roundState) revert(\"Entry Closed\");\n\n        // check each number selection\n        for (uint i = 0; i < _selectedNumbers.length; i++) {\n            if (_selectedNumbers[i] > 30) revert(\"Num > 30\");\n        }\n\n        // check if the amount sent or approved is valid for the ticket purchase\n        uint256 requiredAsset;\n        uint256 roundTicketPrice = roundIdToRoundDetails_[currentRound].ticketPrice;\n\n        if (_nativeAsset) {\n            if (block.chainid == FILECOIN_CHAIN_ID) {\n                requiredAsset = (roundTicketPrice * 10 ** 18) / getAssetPriceUsd(\"fil\");\n                // low wallet balance\n                require(userDetails_[msg.sender].balance.fil >= requiredAsset, \"Low Bal\");\n\n                // deduct from users wallet balance\n                userDetails_[msg.sender].balance.fil -= requiredAsset;\n\n                // update the lotto corss chain balance\n                roundIdToRoundDetails_[currentRound].balance.fil += requiredAsset;\n            }\n\n            if (block.chainid == POLYGON_CHAIN_ID) {\n                requiredAsset = (roundTicketPrice * 10 ** 18) / getAssetPriceUsd(\"matic\");\n                require(\n                    userDetails_[msg.sender].balance.matic >= requiredAsset,\n                    \"Insufficient Wallet Balance\"\n                );\n\n                // deduct from users wallet balance\n                userDetails_[msg.sender].balance.matic -= requiredAsset;\n\n                // update the lotto corss chain balance\n                roundIdToRoundDetails_[currentRound].balance.matic += requiredAsset;\n            }\n        } else {\n            requiredAsset = (roundTicketPrice * 10 ** 18) / getAssetPriceUsd(\"badger\");\n            require(\n                userDetails_[msg.sender].balance.krabz >= requiredAsset,\n                \"Insufficient Wallet Balance\"\n            );\n\n            // deduct from users wallet balance\n            userDetails_[msg.sender].balance.krabz -= requiredAsset;\n\n            // update the lotto corss chain balance\n            roundIdToRoundDetails_[currentRound].balance.krabz += requiredAsset;\n        }\n\n        // if user has bought more than 3 tickets stop em\n        if (ticketsPurchasedPerRound_[currentRound][msg.sender] >= MAX_TICKET_PER_ROUND)\n            revert(\"Max Tickets\");\n\n        // increment round participations => no of tickets purchased\n        uint256 ticketId = roundIdToRoundDetails_[currentRound].ticketsPurchased += 1;\n\n        // update ticket details\n        roundToticketId_[currentRound][ticketId] = Ticket({\n            owner: msg.sender,\n            ID: ticketId,\n            selectedNumbers: _selectedNumbers,\n            withdrawn: false,\n            originChain: block.chainid\n        });\n\n        // update total number of tickets purchased by a user since joining mrkrabz\n        userDetails_[msg.sender].totalTicketsPurchased += 1;\n\n        // update the list of tickets\n        roundIdToTicketList_[currentRound].push(roundToticketId_[currentRound][ticketId]);\n\n        // tickets purchased by round for user\n        ticketsPurchasedPerRound_[currentRound][msg.sender] += 1;\n\n        // handle buy ticket across chains\n        _handleBuyTicketCrossChain(\n            ticketId,\n            msg.sender,\n            _selectedNumbers,\n            block.chainid,\n            _nativeAsset,\n            requiredAsset,\n            currentRound,\n            roundToticketId_[currentRound][ticketId],\n            _estimateGasAmountOne\n        );\n    }\n\n    // claim winnings\n    function claimWinnings(uint256 _ticketId, uint256 _estimateGasAmountOne) public {\n        // the round state must be over\n        if (!roundIdToRoundDetails_[currentRound].roundState) revert(\"Round On\");\n\n        // must withdraw ticket from origin chain\n        if (roundToticketId_[currentRound][_ticketId].originChain != block.chainid)\n            revert(\"! Origin Chain\");\n\n        // must be the owner of the ticket\n        if (roundToticketId_[currentRound][_ticketId].owner != msg.sender) revert(\"! Ticket Owner\");\n\n        // check if the withdrawn state for the ticket is true\n        if (roundToticketId_[currentRound][_ticketId].withdrawn) revert(\"Claimed\");\n\n        // check if the ticket is a winning ticket\n        bool isTicketWinner = isWinner(_ticketId);\n        require(isTicketWinner, \"! Winner\");\n\n        // get the total number of winners\n        uint256 totalWinners = getTotalWinners();\n\n        // get the total pool balance is in usd\n        uint256 roundPoolBalanceInUsd = getRoundPoolBalanceUsd();\n\n        // get individual winner amount in usd\n        uint256 individualWinnerAmount = roundPoolBalanceInUsd / totalWinners;\n\n        // get individual winner amount in krabz\n        uint256 individualWinnerAmountInKrabz = (individualWinnerAmount * 10 ** 18) /\n            getAssetPriceUsd(\"badger\");\n\n        // update users krabz balance\n        userDetails_[msg.sender].balance.krabz += individualWinnerAmountInKrabz;\n        // update winning count\n        userDetails_[msg.sender].totalWinnings += 1;\n\n        // update ticket withdrawal state\n        roundToticketId_[currentRound][_ticketId].withdrawn = true;\n\n        // update the balance cross chain\n        _handleClaimWinningsCrossChain(\n            individualWinnerAmountInKrabz,\n            msg.sender,\n            _estimateGasAmountOne\n        );\n    }\n\n    // claim funds\n    function claimRefund(uint256 _ticketId, uint256 _estimateGasAmountOne) public {\n        // the round state must be over\n        if (!roundIdToRoundDetails_[currentRound].roundState) revert(\"Round On\");\n\n        // must withdraw ticket from origin chain\n        if (roundToticketId_[currentRound][_ticketId].originChain != block.chainid)\n            revert(\"! Origin Chain\");\n\n        // must be the owner of the ticket\n        if (roundToticketId_[currentRound][_ticketId].owner != msg.sender) revert(\"! Ticket Owner\");\n\n        // check if the withdrawn state for the ticket is true\n        if (roundToticketId_[currentRound][_ticketId].withdrawn) revert(\"Ticket Claimed\");\n\n        // check if the ticket is a winning ticket\n        bool isTicketWinner = isWinner(_ticketId);\n        require(!isTicketWinner, \"Winner\");\n\n        uint256 ticketPriceInUsd = roundIdToRoundDetails_[currentRound].ticketPrice;\n\n        // get individual winner amount in krabz\n        uint256 individualRefundAmountInKrabz = (ticketPriceInUsd * 10 ** 18) /\n            getAssetPriceUsd(\"badger\");\n\n        // update users krabz balance\n        userDetails_[msg.sender].balance.krabz += (individualRefundAmountInKrabz * 30) / 100;\n\n        // update ticket withdrawal state\n        roundToticketId_[currentRound][_ticketId].withdrawn = true;\n\n        // update the balance cross chain\n        _handleTopUpWalletBalanceCrossChain(\n            (individualRefundAmountInKrabz * 30) / 100,\n            false,\n            msg.sender,\n            _estimateGasAmountOne\n        );\n    }\n\n    // ADMIN FUNCTIONS (TO BE LATER HANDLED BY CHAINLINK AUTOMATION)\n\n    // start new round\n    function startNewRound(\n        uint256 _roundEndTime,\n        uint256 _ticketPriceInUsd,\n        string memory _roundName,\n        uint256 _estimateGasAmountOne\n    ) public {\n        // special caller check\n        require(msg.sender == deployer, \"!Special Caller\");\n\n        if (block.timestamp < roundIdToRoundDetails_[currentRound].roundEndTime) revert(\"Round On\");\n\n        // set the current round\n        currentRound += 1;\n\n        // update the round details\n        roundIdToRoundDetails_[currentRound].roundId = currentRound;\n        roundIdToRoundDetails_[currentRound].ticketPrice = _ticketPriceInUsd;\n        roundIdToRoundDetails_[currentRound].roundEndTime = block.timestamp + _roundEndTime;\n        roundIdToRoundDetails_[currentRound].roundName = _roundName;\n\n        _handleStartNewRoundCrossChain(\n            currentRound,\n            _roundEndTime + block.timestamp,\n            _ticketPriceInUsd,\n            _roundName,\n            _estimateGasAmountOne\n        );\n    }\n\n    // set round winner\n    function setRoundWinners(\n        uint256 _nonceOne,\n        uint256 _nonceTwo,\n        uint256 _nonceThree,\n        uint256 _estimateGasAmountOne\n    ) public {\n        // special caller check\n        require(msg.sender == deployer, \"!Admin\");\n\n        // makes sure the winners for the round hasnt already been announced\n        if (roundIdToRoundDetails_[currentRound].roundState) revert(\"Announced\");\n\n        // check that the round end time has passed\n        if (block.timestamp < roundIdToRoundDetails_[currentRound].roundEndTime) revert(\"Round On\");\n\n        // you can only set the winners from the fvm chain\n        if (block.chainid != FILECOIN_CHAIN_ID) revert(\"!FVM\");\n\n        //  Intentionally setting the random number to a predictable value:\n        // 1. For testing\n        // 2. Lack of chainlink VRF on FVM as of time of writing\n        uint256 randomNumberOne = uint256(\n            keccak256(abi.encodePacked(PREDICTABLE_VALUE, msg.sender, _nonceOne))\n        ) % 30;\n\n        uint256 randomNumberTwo = uint256(\n            keccak256(abi.encodePacked(PREDICTABLE_VALUE, msg.sender, _nonceTwo))\n        ) % 30;\n\n        uint256 randomNumberThree = uint256(\n            keccak256(abi.encodePacked(PREDICTABLE_VALUE, msg.sender, _nonceThree))\n        ) % 30;\n\n        // random winning numbers\n        uint256[3] memory winningNumbers = [randomNumberOne, randomNumberTwo, randomNumberThree];\n\n        // update round details\n        roundIdToRoundDetails_[currentRound].roundState = true;\n        roundIdToRoundDetails_[currentRound].roundWinningNumbers = winningNumbers;\n\n        _handleSetRandomWinnersCrossChain(currentRound, winningNumbers, _estimateGasAmountOne);\n    }\n\n    ////// CROSS CHAIN HELPER FUNCTIONS /////\n\n    function _handleBuyTicketCrossChain(\n        uint256 _ticketId,\n        address _user,\n        uint256[3] memory _selectedNumbers,\n        uint256 _originChainId,\n        bool _nativeAsset,\n        uint256 _requiredAsset,\n        uint256 _currentRoundId,\n        Ticket memory _ticket,\n        uint256 _estimateGasAmountOne\n    ) internal {\n        // inner payload\n        bytes memory innerPayload = abi.encode(\n            _ticketId,\n            _user,\n            _selectedNumbers,\n            _originChainId,\n            _nativeAsset,\n            _requiredAsset,\n            _currentRoundId,\n            _ticket\n        );\n\n        // main payload\n        bytes memory payload = abi.encode(buyTicketPath, innerPayload);\n\n        if (block.chainid == FILECOIN_CHAIN_ID) {\n            _sendPayloadFromFilecoin(payload, _estimateGasAmountOne);\n        }\n\n        if (block.chainid == POLYGON_CHAIN_ID) {\n            _sendPayloadFromPolygon(payload, _estimateGasAmountOne);\n        }\n    }\n\n    // handle start new round cross chain\n    function _handleStartNewRoundCrossChain(\n        uint256 _currentRound,\n        uint256 _roundEndTime,\n        uint256 _ticketPriceInUsd,\n        string memory _roundName,\n        uint256 _estimateGasAmountOne\n    ) internal {\n        // inner payload\n        bytes memory innerPayload = abi.encode(\n            _currentRound,\n            _roundEndTime,\n            _ticketPriceInUsd,\n            _roundName\n        );\n\n        // payload\n        bytes memory payload = abi.encode(newRoundPath, innerPayload);\n\n        if (block.chainid == FILECOIN_CHAIN_ID)\n            _sendPayloadFromFilecoin(payload, _estimateGasAmountOne);\n\n        if (block.chainid == POLYGON_CHAIN_ID)\n            _sendPayloadFromPolygon(payload, _estimateGasAmountOne);\n    }\n\n    // handle top up wallet balance cross chain\n    function _handleTopUpWalletBalanceCrossChain(\n        uint256 _amount,\n        bool _nativeAsset,\n        address _user,\n        uint256 _estimateGasAmountOne\n    ) internal {\n        if (block.chainid == FILECOIN_CHAIN_ID) {\n            // if native asset is true. pay with it. else use krabz token\n            if (_nativeAsset) userDetails_[_user].balance.fil += _amount;\n            else userDetails_[_user].balance.krabz += _amount;\n\n            // inner payload\n            bytes memory innerPayload = abi.encode(FILECOIN_CHAIN_ID, _nativeAsset, _amount, _user);\n\n            // main payload\n            bytes memory payload = abi.encode(topUpWalletPath, innerPayload);\n\n            _sendPayloadFromFilecoin(payload, _estimateGasAmountOne);\n        }\n\n        if (block.chainid == POLYGON_CHAIN_ID) {\n            // if native asset is true. pay with it. else use krabz token\n            if (_nativeAsset) userDetails_[_user].balance.matic += _amount;\n            else userDetails_[_user].balance.krabz += _amount;\n\n            // inner payload\n            bytes memory innerPayload = abi.encode(FILECOIN_CHAIN_ID, _nativeAsset, _amount, _user);\n\n            // main payload\n            bytes memory payload = abi.encode(topUpWalletPath, innerPayload);\n\n            _sendPayloadFromPolygon(payload, _estimateGasAmountOne);\n        }\n    }\n\n    function _handleClaimWinningsCrossChain(\n        uint256 _individualWinnerAmountInKrabz,\n        address _user,\n        uint256 _estimateGasAmountOne\n    ) internal {\n        if (block.chainid == FILECOIN_CHAIN_ID) {\n            // inner payload\n            bytes memory innerPayload = abi.encode(_individualWinnerAmountInKrabz, _user);\n\n            // main payload\n            bytes memory payload = abi.encode(claimWinningsPath, innerPayload);\n\n            _sendPayloadFromFilecoin(payload, _estimateGasAmountOne);\n        }\n\n        if (block.chainid == POLYGON_CHAIN_ID) {\n            // inner payload\n            bytes memory innerPayload = abi.encode(_individualWinnerAmountInKrabz, _user);\n\n            // main payload\n            bytes memory payload = abi.encode(claimWinningsPath, innerPayload);\n\n            _sendPayloadFromPolygon(payload, _estimateGasAmountOne);\n        }\n    }\n\n    function _handleSetRandomWinnersCrossChain(\n        uint256 _currentRound,\n        uint256[3] memory _randomWinningNumbers,\n        uint256 _estimateGasAmountOne\n    ) internal {\n        bytes memory innerPayload = abi.encode(_currentRound, _randomWinningNumbers);\n\n        bytes memory payload = abi.encode(setRandomWinnersPath, innerPayload);\n\n        if (block.chainid == FILECOIN_CHAIN_ID) {\n            _sendPayloadFromFilecoin(payload, _estimateGasAmountOne);\n        }\n\n        if (block.chainid == POLYGON_CHAIN_ID) {\n            _sendPayloadFromPolygon(payload, _estimateGasAmountOne);\n        }\n    }\n\n    // AXELAR FUNCTIONS\n\n    // Handles calls created by setAndSend. Updates this contract's value\n    function _execute(string calldata, string calldata, bytes calldata payload) internal override {\n        (uint256 executionPath, bytes memory innerPayload) = abi.decode(payload, (uint256, bytes));\n\n        // top up wallet execution path\n        if (executionPath == topUpWalletPath) {\n            (uint256 chainid, bool nativeAsset, uint256 amount, address user) = abi.decode(\n                innerPayload,\n                (uint256, bool, uint256, address)\n            );\n\n            _handleTopupWalletExecutionPath(chainid, nativeAsset, amount, user);\n        }\n\n        // buy ticket path\n        if (executionPath == buyTicketPath) {\n            // unpack innerpayload\n            (\n                uint256 ticketId,\n                address user,\n                uint256[3] memory selectedNumbers,\n                uint256 originChainId,\n                bool nativeAsset,\n                uint256 requiredAsset,\n                uint256 currentRoundId,\n                Ticket memory ticket\n            ) = abi.decode(\n                    innerPayload,\n                    (uint256, address, uint256[3], uint256, bool, uint256, uint256, Ticket)\n                );\n\n            _handleBuyTicketexecutionPath(\n                ticketId,\n                user,\n                selectedNumbers,\n                originChainId,\n                nativeAsset,\n                requiredAsset,\n                currentRoundId,\n                ticket\n            );\n        }\n\n        if (executionPath == newRoundPath) {\n            (\n                uint256 currentRoundId,\n                uint256 roundEndTime,\n                uint256 ticketPriceInUsd,\n                string memory roundName\n            ) = abi.decode(innerPayload, (uint256, uint256, uint256, string));\n\n            // start new round\n            currentRound = currentRoundId;\n\n            // update the round details\n            roundIdToRoundDetails_[currentRoundId].roundId = currentRoundId;\n            roundIdToRoundDetails_[currentRoundId].ticketPrice = ticketPriceInUsd;\n            roundIdToRoundDetails_[currentRoundId].roundEndTime = roundEndTime;\n            roundIdToRoundDetails_[currentRoundId].roundName = roundName;\n        }\n\n        if (executionPath == setRandomWinnersPath) {\n            // unpack innerpayload\n            (uint256 roundId, uint256[3] memory randomWinningNumbers) = abi.decode(\n                innerPayload,\n                (uint256, uint256[3])\n            );\n\n            // update round details\n            roundIdToRoundDetails_[roundId].roundState = true;\n            roundIdToRoundDetails_[roundId].roundWinningNumbers = randomWinningNumbers;\n        }\n\n        if (executionPath == claimWinningsPath) {\n            // unpack inner payload\n            (uint256 individualWinnerAmountInKrabz, address user) = abi.decode(\n                innerPayload,\n                (uint256, address)\n            );\n\n            // update users krabz balance\n            userDetails_[user].balance.krabz += individualWinnerAmountInKrabz;\n\n            // update winning count\n            userDetails_[user].totalWinnings += 1;\n        }\n    }\n\n    ///// EXECUTION PATH HANDLERS ////\n\n    // handle wallet top up execution reception\n    function _handleTopupWalletExecutionPath(\n        uint256 _chainid,\n        bool _nativeAsset,\n        uint256 _amount,\n        address _user\n    ) internal {\n        if (_chainid == FILECOIN_CHAIN_ID) {\n            if (_nativeAsset) userDetails_[_user].balance.fil += _amount;\n            else userDetails_[_user].balance.krabz += _amount;\n        }\n\n        if (_chainid == POLYGON_CHAIN_ID) {\n            if (_nativeAsset) userDetails_[_user].balance.matic += _amount;\n            else userDetails_[_user].balance.krabz += _amount;\n        }\n    }\n\n    // buy ticket execution path\n    function _handleBuyTicketexecutionPath(\n        uint256 _ticketId,\n        address _user,\n        uint256[3] memory _selectedNumbers,\n        uint256 _originChainId,\n        bool _nativeAsset,\n        uint256 _requiredAsset,\n        uint256 _currentRoundId,\n        Ticket memory _ticket\n    ) internal {\n        if (_nativeAsset) {\n            if (_originChainId == FILECOIN_CHAIN_ID) {\n                // deduct from users wallet balance\n                userDetails_[_user].balance.fil -= _requiredAsset;\n\n                // update the lotto corss chain balance\n                roundIdToRoundDetails_[_currentRoundId].balance.fil += _requiredAsset;\n            }\n\n            if (_originChainId == POLYGON_CHAIN_ID) {\n                // deduct from users wallet balance\n                userDetails_[_user].balance.matic -= _requiredAsset;\n\n                // update the lotto corss chain balance\n                roundIdToRoundDetails_[_currentRoundId].balance.matic += _requiredAsset;\n            }\n        } else {\n            // deduct from users wallet balance\n            userDetails_[_user].balance.krabz -= _requiredAsset;\n\n            // update the lotto corss chain balance\n            roundIdToRoundDetails_[_currentRoundId].balance.krabz += _requiredAsset;\n        }\n\n        // increment round participations => no of tickets purchased\n        roundIdToRoundDetails_[_currentRoundId].ticketsPurchased += 1;\n\n        // update ticket details\n        roundToticketId_[_currentRoundId][_ticketId] = Ticket({\n            owner: _user,\n            ID: _ticketId,\n            selectedNumbers: _selectedNumbers,\n            withdrawn: false,\n            originChain: _originChainId\n        });\n\n        // update total number of tickets purchased by a user since joining mrkrabz\n        userDetails_[_user].totalTicketsPurchased += 1;\n\n        // update the list of tickets\n        roundIdToTicketList_[_currentRoundId].push(_ticket);\n\n        // tickets purchased by round for user\n        ticketsPurchasedPerRound_[_currentRoundId][_user] += 1;\n    }\n\n    ///// SEND PAYLOAD CROSS CHAIN FUNCTIONS ////\n\n    // sending cc message from filecoin\n    function _sendPayloadFromFilecoin(\n        bytes memory _payload,\n        uint256 _estimateGasAmountOne\n    ) internal {\n        // Filecoin ->  Polygon\n\n        // approve gas service\n        IERC20(aUsdcTokenAddress).approve(address(gasService), _estimateGasAmountOne);\n\n        // send to Polygon\n        gasService.payGasForContractCallWithToken(\n            address(this),\n            polygonChain,\n            polygonDestinationAddr,\n            _payload,\n            ausdcTokenSymbol,\n            _estimateGasAmountOne,\n            aUsdcTokenAddress,\n            _estimateGasAmountOne,\n            address(this)\n        );\n\n        gateway.callContract(polygonChain, polygonDestinationAddr, _payload);\n    }\n\n    // sending cc message from polygon\n    function _sendPayloadFromPolygon(\n        bytes memory _payload,\n        uint256 _estimateGasAmountOne\n    ) internal {\n        // Polygon -> Filecoin\n\n        // approve gas service\n        IERC20(aUsdcTokenAddress).approve(address(gasService), _estimateGasAmountOne);\n\n        // send to Filecoin\n        gasService.payGasForContractCallWithToken(\n            address(this),\n            filecoinChain,\n            filecoinDestinationAddr,\n            _payload,\n            ausdcTokenSymbol,\n            _estimateGasAmountOne,\n            aUsdcTokenAddress,\n            _estimateGasAmountOne,\n            address(this)\n        );\n        gateway.callContract(filecoinChain, filecoinDestinationAddr, _payload);\n    }\n\n    // ASSET PRICE\n\n    // returns asset price given asset name\n    function getAssetPriceUsd(string memory _assetName) public view returns (uint256) {\n        bytes memory specificQuery = abi.encode(_assetName, \"usd\");\n        bytes memory _queryData = abi.encode(\"SpotPrice\", specificQuery);\n\n        bytes32 _queryId = keccak256(_queryData);\n\n        (bytes memory _value, uint256 _timestampRetrieved) = getDataBefore(\n            _queryId,\n            block.timestamp - 20 minutes\n        );\n        if (_timestampRetrieved == 0) return 0;\n        require(block.timestamp - _timestampRetrieved < 24 hours);\n\n        return abi.decode(_value, (uint256)) / 1e10;\n    }\n\n    ////// HELPER FUNCTIONS /////\n    function isWinner(uint256 _ticketId) public view returns (bool) {\n        uint256[3] memory ticketSelections = roundToticketId_[currentRound][_ticketId]\n            .selectedNumbers;\n\n        uint256[3] memory winningSelections = roundIdToRoundDetails_[currentRound]\n            .roundWinningNumbers;\n        bool equal = _checkEquality(ticketSelections, winningSelections);\n        return equal;\n    }\n\n    function getTotalWinners() public view returns (uint256) {\n        uint256 totalWinners;\n        for (uint i = 0; i < roundIdToTicketList_[currentRound].length; i++) {\n            uint256 ticketId = roundIdToTicketList_[currentRound][i].ID;\n            if (isWinner(ticketId)) {\n                totalWinners += 1;\n            }\n        }\n\n        return totalWinners;\n    }\n\n    function getRoundPoolBalanceUsd() public view returns (uint256) {\n        // fil\n        uint256 filRoundBalance = roundIdToRoundDetails_[currentRound].balance.fil;\n        uint256 filPoolBalanceInUsd = (getAssetPriceUsd(\"fil\") * filRoundBalance) / 10 ** 18;\n\n        // matic\n        uint256 maticRoundBalance = roundIdToRoundDetails_[currentRound].balance.matic;\n        uint256 maticPoolBalanceInUsd = (getAssetPriceUsd(\"matic\") * maticRoundBalance) / 10 ** 18;\n\n        uint256 totalRoundBalance = filPoolBalanceInUsd + maticPoolBalanceInUsd;\n\n        return (totalRoundBalance * 70) / 100;\n    }\n\n    function _checkEquality(\n        uint256[3] memory _winningSelections,\n        uint256[3] memory _userSelections\n    ) internal pure returns (bool) {\n        for (uint256 i = 0; i < _winningSelections.length; i++) {\n            if (_winningSelections[i] != _userSelections[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    ////// UI GETTER FUNCTIONS /////\n\n    // get user details\n    function getUserDetails(address _user) public view returns (User memory) {\n        return userDetails_[_user];\n    }\n\n    // get users tickets\n    function getUserTicketsForCurrentRound(address _user) public view returns (Ticket[] memory) {\n        uint256 ticketCount = 0;\n\n        // count the number of tickets owned by the user\n        for (uint i = 0; i < roundIdToTicketList_[currentRound].length; i++) {\n            if (roundIdToTicketList_[currentRound][i].owner == _user) {\n                ticketCount++;\n            }\n        }\n\n        // create a new array to store the users tickets\n        Ticket[] memory userTickets = new Ticket[](ticketCount);\n        uint256 currentIndex = 0;\n\n        // iterate over the tickets and populate the user's ticket array\n        for (uint i = 0; i < roundIdToTicketList_[currentRound].length; i++) {\n            if (roundIdToTicketList_[currentRound][i].owner == _user) {\n                userTickets[currentIndex] = roundIdToTicketList_[currentRound][i];\n            }\n\n            currentIndex += 1;\n        }\n\n        return userTickets;\n    }\n\n    //get current round\n    function getCurrentRoundDetails() public view returns (Round memory) {\n        return roundIdToRoundDetails_[currentRound];\n    }\n\n    ////// UPDATE FUNCTIONS //////\n    function updateDestinationAddresses(\n        string memory _filDestinationAddress,\n        string memory _polygonDestinationAddress\n    ) public {\n        filecoinDestinationAddr = _filDestinationAddress;\n        polygonDestinationAddr = _polygonDestinationAddress;\n    }\n\n    // WITHDRAW FROM CROSS CHAIN WALLET ??????????\n\n    ////// WITHDRAWAL FUNCTIONS  ////////\n    function withdrawAllKrabz() public {\n        uint256 contractTokenBalance = IERC20(krabzTokenAddress).balanceOf(address(this));\n        IERC20(krabzTokenAddress).transfer(msg.sender, contractTokenBalance);\n    }\n\n    function withdrawAllUsdcToken() public {\n        uint256 contractBalance = IERC20(aUsdcTokenAddress).balanceOf(address(this));\n        IERC20(aUsdcTokenAddress).transfer(msg.sender, contractBalance);\n    }\n\n    function withdrawNativeAsset() public {\n        uint256 contractBalance = address(this).balance;\n        (bool success, ) = msg.sender.call{value: contractBalance}(\"\");\n        require(success, \"!successful\");\n    }\n}\n"
    },
    "usingtellor/contracts/interface/IERC2362.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n    * @dev EIP2362 Interface for pull oracles\n    * https://github.com/tellor-io/EIP-2362\n*/\ninterface IERC2362\n{\n\t/**\n\t * @dev Exposed function pertaining to EIP standards\n\t * @param _id bytes32 ID of the query\n\t * @return int,uint,uint returns the value, timestamp, and status code of query\n\t */\n\tfunction valueFor(bytes32 _id) external view returns(int256,uint256,uint256);\n}"
    },
    "usingtellor/contracts/interface/IMappingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMappingContract{\n    function getTellorID(bytes32 _id) external view returns(bytes32);\n}"
    },
    "usingtellor/contracts/interface/ITellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITellor {\n    //Controller\n    function addresses(bytes32) external view returns (address);\n\n    function uints(bytes32) external view returns (uint256);\n\n    function burn(uint256 _amount) external;\n\n    function changeDeity(address _newDeity) external;\n\n    function changeOwner(address _newOwner) external;\n    function changeUint(bytes32 _target, uint256 _amount) external;\n\n    function migrate() external;\n\n    function mint(address _reciever, uint256 _amount) external;\n\n    function init() external;\n\n    function getAllDisputeVars(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            bool,\n            bool,\n            bool,\n            address,\n            address,\n            address,\n            uint256[9] memory,\n            int256\n        );\n\n    function getDisputeIdByDisputeHash(bytes32 _hash)\n        external\n        view\n        returns (uint256);\n\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\n        external\n        view\n        returns (uint256);\n\n    function getLastNewValueById(uint256 _requestId)\n        external\n        view\n        returns (uint256, bool);\n\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    function getNewValueCountbyRequestId(uint256 _requestId)\n        external\n        view\n        returns (uint256);\n\n    function getAddressVars(bytes32 _data) external view returns (address);\n\n    function getUintVar(bytes32 _data) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function isMigrated(address _addy) external view returns (bool);\n\n    function allowance(address _user, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function allowedToTrade(address _user, uint256 _amount)\n        external\n        view\n        returns (bool);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function approveAndTransferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool);\n\n    function balanceOf(address _user) external view returns (uint256);\n\n    function balanceOfAt(address _user, uint256 _blockNumber)\n        external\n        view\n        returns (uint256);\n\n    function transfer(address _to, uint256 _amount)\n        external\n        returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool success);\n\n    function depositStake() external;\n\n    function requestStakingWithdraw() external;\n\n    function withdrawStake() external;\n\n    function changeStakingStatus(address _reporter, uint256 _status) external;\n\n    function slashReporter(address _reporter, address _disputer) external;\n\n    function getStakerInfo(address _staker)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    function getNewCurrentVariables()\n        external\n        view\n        returns (\n            bytes32 _c,\n            uint256[5] memory _r,\n            uint256 _d,\n            uint256 _t\n        );\n\n    function getNewValueCountbyQueryId(bytes32 _queryId)\n        external\n        view\n        returns (uint256);\n\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory);\n\n    //Governance\n    enum VoteResult {\n        FAILED,\n        PASSED,\n        INVALID\n    }\n\n    function setApprovedFunction(bytes4 _func, bool _val) external;\n\n    function beginDispute(bytes32 _queryId, uint256 _timestamp) external;\n\n    function delegate(address _delegate) external;\n\n    function delegateOfAt(address _user, uint256 _blockNumber)\n        external\n        view\n        returns (address);\n\n    function executeVote(uint256 _disputeId) external;\n\n    function proposeVote(\n        address _contract,\n        bytes4 _function,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) external;\n\n    function tallyVotes(uint256 _disputeId) external;\n\n    function governance() external view returns (address);\n\n    function updateMinDisputeFee() external;\n\n    function verify() external pure returns (uint256);\n\n    function vote(\n        uint256 _disputeId,\n        bool _supports,\n        bool _invalidQuery\n    ) external;\n\n    function voteFor(\n        address[] calldata _addys,\n        uint256 _disputeId,\n        bool _supports,\n        bool _invalidQuery\n    ) external;\n\n    function getDelegateInfo(address _holder)\n        external\n        view\n        returns (address, uint256);\n\n    function isFunctionApproved(bytes4 _func) external view returns (bool);\n\n    function isApprovedGovernanceContract(address _contract)\n        external\n        returns (bool);\n\n    function getVoteRounds(bytes32 _hash)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getVoteCount() external view returns (uint256);\n\n    function getVoteInfo(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            uint256[9] memory,\n            bool[2] memory,\n            VoteResult,\n            bytes memory,\n            bytes4,\n            address[2] memory\n        );\n\n    function getDisputeInfo(uint256 _disputeId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bytes memory,\n            address\n        );\n\n    function getOpenDisputesOnId(bytes32 _queryId)\n        external\n        view\n        returns (uint256);\n\n    function didVote(uint256 _disputeId, address _voter)\n        external\n        view\n        returns (bool);\n\n    //Oracle\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory);\n\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    function getReportingLock() external view returns (uint256);\n\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (address);\n\n    function reportingLock() external view returns (uint256);\n\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\n    function getTipsByUser(address _user) external view returns(uint256);\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\n    function burnTips() external;\n\n    function changeReportingLock(uint256 _newReportingLock) external;\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\n    function getTimeBasedReward() external view returns(uint256);\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\n    function getCurrentReward(bytes32 _queryId) external view returns(uint256, uint256);\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp) external view returns(bool _ifRetrieve, bytes memory _value, uint256 _timestampRetrieved);\n    function getTimeOfLastNewValue() external view returns(uint256);\n    function depositStake(uint256 _amount) external;\n    function requestStakingWithdraw(uint256 _amount) external;\n\n    //Test functions\n    function changeAddressVar(bytes32 _id, address _addy) external;\n\n    //parachute functions\n    function killContract() external;\n\n    function migrateFor(address _destination, uint256 _amount) external;\n\n    function rescue51PercentAttack(address _tokenHolder) external;\n\n    function rescueBrokenDataReporting() external;\n\n    function rescueFailedUpdate() external;\n\n    //Tellor 360\n    function addStakingRewards(uint256 _amount) external;\n\n    function _sliceUint(bytes memory _b)\n        external\n        pure\n        returns (uint256 _number);\n\n    function claimOneTimeTip(bytes32 _queryId, uint256[] memory _timestamps)\n        external;\n\n    function claimTip(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256[] memory _timestamps\n    ) external;\n\n    function fee() external view returns (uint256);\n\n    function feedsWithFunding(uint256) external view returns (bytes32);\n\n    function fundFeed(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256 _amount\n    ) external;\n\n    function getCurrentFeeds(bytes32 _queryId)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getCurrentTip(bytes32 _queryId) external view returns (uint256);\n\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved);\n\n    function getDataFeed(bytes32 _feedId)\n        external\n        view\n        returns (Autopay.FeedDetails memory);\n\n    function getFundedFeeds() external view returns (bytes32[] memory);\n\n    function getFundedQueryIds() external view returns (bytes32[] memory);\n\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bool _found, uint256 _index);\n\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bool _found, uint256 _index);\n\n    function getMultipleValuesBefore(\n        bytes32 _queryId,\n        uint256 _timestamp,\n        uint256 _maxAge,\n        uint256 _maxCount\n    )\n        external\n        view\n        returns (uint256[] memory _values, uint256[] memory _timestamps);\n\n    function getPastTipByIndex(bytes32 _queryId, uint256 _index)\n        external\n        view\n        returns (Autopay.Tip memory);\n\n    function getPastTipCount(bytes32 _queryId) external view returns (uint256);\n\n    function getPastTips(bytes32 _queryId)\n        external\n        view\n        returns (Autopay.Tip[] memory);\n\n    function getQueryIdFromFeedId(bytes32 _feedId)\n        external\n        view\n        returns (bytes32);\n\n    function getRewardAmount(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256[] memory _timestamps\n    ) external view returns (uint256 _cumulativeReward);\n\n    function getRewardClaimedStatus(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bool);\n\n    function getTipsByAddress(address _user) external view returns (uint256);\n\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bool);\n\n    function queryIdFromDataFeedId(bytes32) external view returns (bytes32);\n\n    function queryIdsWithFunding(uint256) external view returns (bytes32);\n\n    function queryIdsWithFundingIndex(bytes32) external view returns (uint256);\n\n    function setupDataFeed(\n        bytes32 _queryId,\n        uint256 _reward,\n        uint256 _startTime,\n        uint256 _interval,\n        uint256 _window,\n        uint256 _priceThreshold,\n        uint256 _rewardIncreasePerSecond,\n        bytes memory _queryData,\n        uint256 _amount\n    ) external;\n\n    function tellor() external view returns (address);\n\n    function tip(\n        bytes32 _queryId,\n        uint256 _amount,\n        bytes memory _queryData\n    ) external;\n\n    function tips(bytes32, uint256)\n        external\n        view\n        returns (uint256 amount, uint256 timestamp);\n\n    function token() external view returns (address);\n\n    function userTipsTotal(address) external view returns (uint256);\n\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256 _value,\n            uint256 _timestamp,\n            uint256 _statusCode\n        );\n}\n\ninterface Autopay {\n    struct FeedDetails {\n        uint256 reward;\n        uint256 balance;\n        uint256 startTime;\n        uint256 interval;\n        uint256 window;\n        uint256 priceThreshold;\n        uint256 rewardIncreasePerSecond;\n        uint256 feedsWithFundingIndex;\n    }\n\n    struct Tip {\n        uint256 amount;\n        uint256 timestamp;\n    }\n    function getStakeAmount() external view returns(uint256);\n    function stakeAmount() external view returns(uint256);\n    function token() external view returns(address);\n}\n"
    },
    "usingtellor/contracts/UsingTellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./interface/ITellor.sol\";\nimport \"./interface/IERC2362.sol\";\nimport \"./interface/IMappingContract.sol\";\n\n/**\n @author Tellor Inc\n @title UsingTellor\n @dev This contract helps smart contracts read data from Tellor\n */\ncontract UsingTellor is IERC2362 {\n    ITellor public tellor;\n    IMappingContract public idMappingContract;\n\n    /*Constructor*/\n    /**\n     * @dev the constructor sets the oracle address in storage\n     * @param _tellor is the Tellor Oracle address\n     */\n    constructor(address payable _tellor) {\n        tellor = ITellor(_tellor);\n    }\n\n    /*Getters*/\n    /**\n     * @dev Retrieves the next value for the queryId after the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp after which to search for next value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved)\n    {\n        (bool _found, uint256 _index) = getIndexForDataAfter(\n            _queryId,\n            _timestamp\n        );\n        if (!_found) {\n            return (\"\", 0);\n        }\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _index);\n        _value = retrieveData(_queryId, _timestampRetrieved);\n        return (_value, _timestampRetrieved);\n    }\n\n    /**\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp before which to search for latest value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved)\n    {\n        (, _value, _timestampRetrieved) = tellor.getDataBefore(\n            _queryId,\n            _timestamp\n        );\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool _found, uint256 _index)\n    {\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\n        if (_count == 0) return (false, 0);\n        _count--;\n        bool _search = true; // perform binary search\n        uint256 _middle = 0;\n        uint256 _start = 0;\n        uint256 _end = _count;\n        uint256 _timestampRetrieved;\n        // checking boundaries to short-circuit the algorithm\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _end);\n        if (_timestampRetrieved <= _timestamp) return (false, 0);\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _start);\n        if (_timestampRetrieved > _timestamp) {\n            // candidate found, check for disputes\n            _search = false;\n        }\n        // since the value is within our boundaries, do a binary search\n        while (_search) {\n            _middle = (_end + _start) / 2;\n            _timestampRetrieved = getTimestampbyQueryIdandIndex(\n                _queryId,\n                _middle\n            );\n            if (_timestampRetrieved > _timestamp) {\n                // get immediate previous value\n                uint256 _prevTime = getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle - 1\n                );\n                if (_prevTime <= _timestamp) {\n                    // candidate found, check for disputes\n                    _search = false;\n                } else {\n                    // look from start to middle -1(prev value)\n                    _end = _middle - 1;\n                }\n            } else {\n                // get immediate next value\n                uint256 _nextTime = getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle + 1\n                );\n                if (_nextTime > _timestamp) {\n                    // candidate found, check for disputes\n                    _search = false;\n                    _middle++;\n                    _timestampRetrieved = _nextTime;\n                } else {\n                    // look from middle + 1(next value) to end\n                    _start = _middle + 1;\n                }\n            }\n        }\n        // candidate found, check for disputed values\n        if (!isInDispute(_queryId, _timestampRetrieved)) {\n            // _timestampRetrieved is correct\n            return (true, _middle);\n        } else {\n            // iterate forward until we find a non-disputed value\n            while (\n                isInDispute(_queryId, _timestampRetrieved) && _middle < _count\n            ) {\n                _middle++;\n                _timestampRetrieved = getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle\n                );\n            }\n            if (\n                _middle == _count && isInDispute(_queryId, _timestampRetrieved)\n            ) {\n                return (false, 0);\n            }\n            // _timestampRetrieved is correct\n            return (true, _middle);\n        }\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool _found, uint256 _index)\n    {\n        return tellor.getIndexForDataBefore(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieves multiple uint256 values before the specified timestamp\n     * @param _queryId the unique id of the data query\n     * @param _timestamp the timestamp before which to search for values\n     * @param _maxAge the maximum number of seconds before the _timestamp to search for values\n     * @param _maxCount the maximum number of values to return\n     * @return _values the values retrieved, ordered from oldest to newest\n     * @return _timestamps the timestamps of the values retrieved\n     */\n    function getMultipleValuesBefore(\n        bytes32 _queryId,\n        uint256 _timestamp,\n        uint256 _maxAge,\n        uint256 _maxCount\n    )\n        public\n        view\n        returns (bytes[] memory _values, uint256[] memory _timestamps)\n    {\n        // get index of first possible value\n        (bool _ifRetrieve, uint256 _startIndex) = getIndexForDataAfter(\n            _queryId,\n            _timestamp - _maxAge\n        );\n        // no value within range\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _endIndex;\n        // get index of last possible value\n        (_ifRetrieve, _endIndex) = getIndexForDataBefore(_queryId, _timestamp);\n        // no value before _timestamp\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _valCount = 0;\n        uint256 _index = 0;\n        uint256[] memory _timestampsArrayTemp = new uint256[](_maxCount);\n        // generate array of non-disputed timestamps within range\n        while (_valCount < _maxCount && _endIndex + 1 - _index > _startIndex) {\n            uint256 _timestampRetrieved = getTimestampbyQueryIdandIndex(\n                _queryId,\n                _endIndex - _index\n            );\n            if (!isInDispute(_queryId, _timestampRetrieved)) {\n                _timestampsArrayTemp[_valCount] = _timestampRetrieved;\n                _valCount++;\n            }\n            _index++;\n        }\n\n        bytes[] memory _valuesArray = new bytes[](_valCount);\n        uint256[] memory _timestampsArray = new uint256[](_valCount);\n        // retrieve values and reverse timestamps order\n        for (uint256 _i = 0; _i < _valCount; _i++) {\n            _timestampsArray[_i] = _timestampsArrayTemp[_valCount - 1 - _i];\n            _valuesArray[_i] = retrieveData(_queryId, _timestampsArray[_i]);\n        }\n        return (_valuesArray, _timestampsArray);\n    }\n\n    /**\n     * @dev Counts the number of values that have been submitted for the queryId\n     * @param _queryId the id to look up\n     * @return uint256 count of the number of values received for the queryId\n     */\n    function getNewValueCountbyQueryId(bytes32 _queryId)\n        public\n        view\n        returns (uint256)\n    {\n        return tellor.getNewValueCountbyQueryId(_queryId);\n    }\n\n    /**\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find a corresponding reporter for\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\n     */\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (address)\n    {\n        return tellor.getReporterByTimestamp(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _queryId is the id to look up\n     * @param _index is the value index to look up\n     * @return uint256 timestamp\n     */\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\n        public\n        view\n        returns (uint256)\n    {\n        return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\n    }\n\n    /**\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\n     * @param _queryId is the value id to look up\n     * @param _timestamp is the timestamp of the value to look up\n     * @return bool true if queryId/timestamp is under dispute\n     */\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool)\n    {\n        return tellor.isInDispute(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieve value from oracle based on queryId/timestamp\n     * @param _queryId being requested\n     * @param _timestamp to retrieve data/value from\n     * @return bytes value for query/timestamp submitted\n     */\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bytes memory)\n    {\n        return tellor.retrieveData(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev allows dev to set mapping contract for valueFor (EIP2362)\n     * @param _addy address of mapping contract\n     */\n    function setIdMappingContract(address _addy) external {\n        require(address(idMappingContract) == address(0));\n        idMappingContract = IMappingContract(_addy);\n    }\n\n    /**\n     * @dev Retrieve most recent int256 value from oracle based on queryId\n     * @param _id being requested\n     * @return _value most recent value submitted\n     * @return _timestamp timestamp of most recent value\n     * @return _statusCode 200 if value found, 404 if not found\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        override\n        returns (\n            int256 _value,\n            uint256 _timestamp,\n            uint256 _statusCode\n        )\n    {\n        bytes32 _queryId = idMappingContract.getTellorID(_id);\n        bytes memory _valueBytes;\n        (_valueBytes, _timestamp) = getDataBefore(\n            _queryId,\n            block.timestamp + 1\n        );\n        if (_timestamp == 0) {\n            return (0, 0, 404);\n        }\n        uint256 _valueUint = _sliceUint(_valueBytes);\n        _value = int256(_valueUint);\n        return (_value, _timestamp, 200);\n    }\n\n    // Internal functions\n    /**\n     * @dev Convert bytes to uint256\n     * @param _b bytes value to convert to uint256\n     * @return _number uint256 converted from bytes\n     */\n    function _sliceUint(bytes memory _b)\n        internal\n        pure\n        returns (uint256 _number)\n    {\n        for (uint256 _i = 0; _i < _b.length; _i++) {\n            _number = _number * 256 + uint8(_b[_i]);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": false
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}